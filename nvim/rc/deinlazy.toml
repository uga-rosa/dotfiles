[[plugins]]
repo = 'Shougo/dein.vim'

[[plugins]]
repo = 'hrsh7th/vim-vsnip'
on_event = 'InsertEnter'
on_ft = 'snippets'
hook_source = '''
    let g:vsnip_snippet_dir = stdpath('config') . '/snippets'
    let g:vsnip_choice_delay = 200
'''

[[plugins]]
repo = 'cohama/lexima.vim'
on_event = 'InsertEnter'
hook_source = '''
    let g:lexima_ctrlh_as_backspace = 1
    let s:lexima_my_rules = [
          \ #{
          \   char: '<CR>',
          \   at: '{\%#}',
          \   input: '<CR>\ ',
          \   input_after: '<CR>\ ',
          \   filetype: 'vim'
          \ },
          \ #{
          \   char: '<CR>',
          \   at: '\[\%#]',
          \   input: '<CR>\ ',
          \   input_after: '<CR>\ ',
          \   filetype: 'vim'
          \ }]
    for rule in s:lexima_my_rules
      call lexima#add_rule(rule)
    endfor
'''

[[plugins]]
repo = 'machakann/vim-sandwich'
on_map = ['<Plug>', '<Plug>(textobj-sandwich-']
hook_add = '''
    let g:operator_sandwich_no_default_key_mappings = 1
    let g:textobj_sandwich_no_default_key_mappings = 1
    " operator
    Keymap nxo sa  <Plug>(sandwich-add)
    Keymap nx  sd  <Plug>(sandwich-delete)
    Keymap n   sdb <Plug>(sandwich-delete-auto)
    Keymap nx  sr  <Plug>(sandwich-replace)
    Keymap n   srb <Plug>(sandwich-replace-auto)
    " textobject
    Keymap xo  ib <Plug>(textobj-sandwich-auto-i)
    Keymap xo  ab <Plug>(textobj-sandwich-auto-a)
    Keymap xo  is <Plug>(textobj-query-auto-i)
    Keymap xo  as <Plug>(textobj-query-auto-a)
'''
hook_source = '''
    call operator#sandwich#set('add', 'char', 'skip_space', 1)
'''

[[plugins]]
repo = 'kana/vim-operator-user'

[[plugins]]
repo = 'yuki-yano/vim-operator-replace'
depends = 'vim-operator-user'
on_map = '<Plug>'
hook_add = '''
    Keymap nxo r <Plug>(operator-replace)
'''

[[plugins]]
repo = 'haya14busa/vim-edgemotion'
on_map = "<Plug>"
hook_add = '''
    Keymap nxo <C-j> <Plug>(edgemotion-j)
    Keymap nxo <C-k> <Plug>(edgemotion-k)
'''

[[plugins]]
repo = 'ibhagwan/fzf-lua'
depends = ['nvim-web-devicons', 'mr.vim']
on_cmd = 'FzfLua'
on_lua = 'fzf-lua'
hook_add = '''
    nnoremap <leader>r  <Cmd>FzfLua resume<CR>
    nnoremap <leader>f  <Cmd>FzfLua files<CR>
    nnoremap <leader>b  <Cmd>FzfLua buffers<CR>
    nnoremap <leader>o  <Cmd>FzfLua oldfiles<CR>
    nnoremap <leader>lg <Cmd>FzfLua live_grep<CR>
    nnoremap <leader>/  <Cmd>FzfLua blines<CR>
    nnoremap <leader>gf <Cmd>FzfLua git_files<CR>
    nnoremap <leader>h  <Cmd>FzfLua help_tags<CR>
    nnoremap q:         <Cmd>FzfLua command_history<CR>
    nnoremap q;         q:
    nnoremap q/         <Cmd>FzfLua search_history<CR>

    nnoremap <leader>i  <Cmd>FzfLua diagnostics_document<CR>
    nnoremap gr         <Cmd>FzfLua lsp_references<CR>
'''
lua_add = '''
    vim.keymap.set("n", "<leader>m", function()
      require("fzf-lua").fzf_exec(vim.fn["mr#mru#list"](), {
        previewer = "builtin",
        prompt = "MRU> ",
        fzf_opts = {
          ["--no-sort"] = "",
        },
      })
    end, {})
'''
lua_source = '''
    local actions = require("fzf-lua.actions")

    local fd_opts = {
      "--color=never",
      "--type", "f",
      "--hidden",
      "--follow",
      "--exclude", ".git",
      "--exclude", "*.png",
      "--exclude", "*.xlsx",
      "--exclude", "*.docx",
      "--exclude", "*.pdf",
    }

    require("fzf-lua").setup({
      actions = {
        files = {
          ["default"] = actions.file_edit_or_qf,
          ["ctrl-x"]  = actions.file_split,
          ["ctrl-v"]  = actions.file_vsplit,
          ["ctrl-t"]  = actions.file_tabedit,
          ["alt-q"]   = actions.file_sel_to_qf,
          ["alt-l"]   = actions.file_sel_to_ll,
        },
        buffers = {
          ["default"] = actions.buf_edit,
          ["ctrl-x"]  = actions.buf_split,
          ["ctrl-v"]  = actions.buf_vsplit,
          ["ctrl-t"]  = actions.buf_tabedit,
        },
      },
      files = {
        prompt = "Files❯ ",
        fd_opts = table.concat(fd_opts, " "),
      },
      buffers = {
        actions = {
          ["ctrl-x"] = actions.buf_split,
          ["ctrl-d"] = actions.buf_del,
        },
      },
      file_icon_padding = " ",
    })
'''
[plugins.ftplugin]
fzf = '''
    tnoremap <buffer> <C-t> <C-t>
'''

[[plugins]]
repo = 'lambdalisue/mr.vim'
rev = 'main'
hook_source = '''
    let g:mr_mru_disabled = 1
    let g:mr_mrr_disabled = 1
'''

[[plugins]]
repo = 'nvim-treesitter/nvim-treesitter'
depends = ['nvim-treesitter-textobjects', 'nvim-ts-rainbow']
on_event = 'BufRead'
hook_post_update = 'TSUpdate'
lua_source = '''
    local parser_install_dir = vim.fn.stdpath("data") .. "/treesitter"
    vim.opt.runtimepath:append(parser_install_dir)

    require("nvim-treesitter.configs").setup({
      ensure_installed = {
        "lua",
        "vim",
        "toml",
        "query",
        "markdown",
        "python",
        "go",
      },
      parser_install_dir = parser_install_dir,
      highlight = {
        enable = true,
        disable = { "help" },
      },
      textobjects = {
        select = {
          enable = true,
          lookahead = true,
          keymaps = {
            ["ib"] = "@block.inner",
            ["ab"] = "@block.outer",
            ["if"] = "@function.inner",
            ["af"] = "@function.outer",
            ["il"] = "@loop.inner",
            ["al"] = "@loop.outer",
          },
        },
        swap = {
          enable = true,
          swap_next = {
            ["<M-s>"] = "@parameter.inner",
          },
          swap_previous = {
            ["<M-S-s>"] = "@parameter.inner",
          },
        },
      },
      rainbow = {
        enable = true,
        extended_mode = true,
        max_file_lines = nil,
      },
    })
'''

[[plugins]]
repo = 'nvim-treesitter/nvim-treesitter-textobjects'

[[plugins]]
repo = 'p00f/nvim-ts-rainbow'

[[plugins]]
repo = 'nvim-treesitter/playground'
on_cmd = 'TSPlaygroundToggle'

[[plugins]]
repo = 'lambdalisue/fern.vim'
on_cmd = 'Fern'
hook_add = '''
    nnoremap <M-f> <Cmd>Fern . -drawer -toggle<CR>
'''
hook_source = '''
    augroup my-fern
      au!
      au FileType fern call s:fern_mapping()
    augroup END

    function! s:fern_mapping()
      nnoremap <buffer> <C-x> <Plug>(fern-action-open:split)
      nnoremap <buffer> <C-v> <Plug>(fern-action-open:vsplit)
    endfunction
'''

[[plugins]]
repo = 'lewis6991/gitsigns.nvim'
on_event = 'BufRead'
lua_source = '''
    local gs = require("gitsigns")
    gs.setup({
      on_attach = function(bufnr)
        local function map(mode, l, r, opts)
          opts = vim.F.if_nil(opts, {})
          opts.buffer = bufnr
          vim.keymap.set(mode, l, r, opts)
        end
        -- Navigates
        map("n", "]g", function()
          if vim.wo.diff then
            return "]g"
          end
          vim.schedule(function()
            gs.next_hunk()
          end)
          return "<Ignore>"
        end, { expr = true })
        map("n", "[g", function()
          if vim.wo.diff then
            return "[g"
          end
          vim.schedule(function()
            gs.prev_hunk()
          end)
          return "<Ignore>"
        end, { expr = true })
        -- Actions
        map({ "n", "v" }, "<leader>gs", ":Gitsigns stage_hunk<CR>")
        map({ "n", "v" }, "<leader>gu", ":Gitsigns undo_stage_hunk<CR>")
        map({ "n", "v" }, "<leader>gr", ":Gitsigns reset_hunk<CR>")
        -- Text object
        map({ "o", "x" }, "ig", ":<C-U>Gitsigns select_hunk<CR>")
      end,
    })
'''

[[plugins]]
repo = 'hrsh7th/vim-searchx'
depends = 'kensaku.vim'
on_func = 'searchx#start'
hook_add = '''
    Keymap nx / <Cmd>call searchx#start({'dir': 1})<CR>
    Keymap nx ? <Cmd>call searchx#start({'dir': 0})<CR>

    Keymap nx n     <Cmd>call searchx#next()<CR>
    Keymap nx N     <Cmd>call searchx#prev()<CR>
    Keymap c  <C-l> <Cmd>call searchx#clear()<CR>
'''
lua_source = '''
    vim.g.searchx = {
      auto_accept = true,
      scrolloff = vim.opt.scrolloff:get(),
      scrolltime = 0,
      nohlsearch = {
        jump = true,
      },
      markers = vim.split("ASDFGHJKL:QWERTYUIOP", ""),
    }
'''
hook_post_source = '''
    cnoremap <M-j> <Cmd>call ToggleSearchxMigemo()<CR>

    let g:searchx_kensaku = 0
    function! ToggleSearchxMigemo() abort
      if g:searchx_kensaku
        let g:searchx.convert = { input -> input }
      else
        unlet g:searchx.convert
        function g:searchx.convert(input) abort
          return kensaku#query(a:input)
        endfunction
      endif
      let g:searchx_kensaku = !g:searchx_kensaku
      call searchx#redraw()
      lua require('lualine').refresh()
      redrawstatus
    endfunction
'''

[[plugins]]
repo = 'yuki-yano/fuzzy-motion.vim'
depends = ['denops.vim', 'kensaku.vim']
on_cmd = 'FuzzyMotion'
hook_add = '''
    nnoremap ss <Cmd>FuzzyMotion<CR>
    let g:fuzzy_motion_matchers = ['fzf', 'kensaku']
'''

[[plugins]]
repo = 'tyru/open-browser.vim'
on_map = '<Plug>(openbrowser-smart-search)'
hook_add = '''
    let g:openbrowser_browser_commands = [
    \   {
    \     'name': 'vivaldi.exe',
    \     'args': ['{browser}', '{uri}']
    \   }
    \]
    Keymap nx <M-o> <Plug>(openbrowser-smart-search)
'''

[[plugins]]
repo = 'simeji/winresizer'
on_cmd = 'WinResizerStartResize'
hook_add = '''
    nnoremap <C-e> <Cmd>WinResizerStartResize<CR>
'''

[[plugins]]
repo = 'junegunn/vim-easy-align'
on_map = '<Plug>(EasyAlign)'
hook_add = '''
    Keymap nx ga <Plug>(EasyAlign)
'''

[[plugins]]
repo = 'thinca/vim-quickrun'
depends = 'vim-quickrun-neovim-job'
on_cmd = 'QuickRun'
hook_add = '''
    nnoremap @r <Cmd>QuickRun<CR>
'''
lua_source = '''
    vim.g.quickrun_config = {
      _ = {
        runner = "neovim_job",
        outputter = "error",
        ["outputter/error/success"] = "buffer",
        ["outputter/error/error"] = "quickfix",
        ["outputter/buffer/opener"] = "botright 10sp",
        ["outputter/buffer/close_on_empty"] = true,
      },
      typescript = {
        command = "deno",
        exec = "%C run -A %S",
      },
      lua = {
        command = ":luafile",
        exec = "%C %S",
        runner = "vimscript",
      },
      lua_vusted = {
        command = "vusted",
        exec = "%C %s",
      },
      nimble = {
        command = "nimble",
        exec = "%C run",
      },
      nimble_test = {
        command = "nimble",
        exec = "%C test",
      },
    }
'''

[[plugins]]
repo = 'lambdalisue/vim-quickrun-neovim-job'

[[plugins]]
repo = 'hrsh7th/vim-gindent'
hook_add = '''
    let g:indent = {}
    let g:indent.enabled = { -> index(['vim', 'lua'], &ft) != -1 }
'''

[[plugins]]
repo = 'thinca/vim-partedit'
on_cmd = 'Partedit'
hook_add = '''
    let g:partedit#prefix_pattern = '\s*'
    let g:partedit#auto_prefix = 0
'''

[[plugins]]
repo = 'monaqa/nvim-treesitter-clipping'
depends = ['nvim-treesitter', 'vim-partedit']
on_lua = 'nvim-treesitter-clipping'
lua_add = '''
    vim.api.nvim_create_autocmd("FileType", {
      pattern = { "toml", "markdown" },
      callback = function()
        vim.keymap.set("n", "<C-p>", function()
          require("nvim-treesitter-clipping.internal").clip()
          vim.keymap.set("n", "Q", "<Cmd>w<CR><Cmd>ParteditEnd<CR>", { buffer = true })
        end, { buffer = true })
      end,
    })
'''

[[plugins]]
repo = '~/plugin/linkformat.vim'
on_cmd = 'LinkFormatPaste'
hook_add = '''
    let g:linkformat_template = join(['[[plugins]]', "repo = '<>'"], "\n")
'''

[[plugins]]
repo = '~/plugin/translate.nvim'
on_cmd = 'Translate'
lua_add = '''
    local mappings = {
      f = "-output=floating",
      s = "-output=split",
      i = "-output=insert",
      r = "-output=replace",
      c = "-comment",
    }

    for k, v in pairs(mappings) do
      vim.keymap.set({"n", "x"}, "mj" .. k, ("<Cmd>Translate JA -source=EN %s<CR><Esc>"):format(v))
      vim.keymap.set({"n", "x"}, "me" .. k, ("<Cmd>Translate EN -source=JA %s<CR><Esc>"):format(v))
    end
'''
lua_source = '''
    require("translate").setup({
      default = {
        command = "translate_shell",
      },
      preset = {
        output = {
          split = {
            append = true,
          },
        },
      },
    })
'''

[plugins.ftplugin]
translate = '''
    nnoremap <buffer><nowait> q <Cmd>quit<CR>
'''

[[plugins]]
repo = '~/plugin/ccc.nvim'
on_event = 'BufRead'
hook_add = '''
    nnoremap <C-c> <Cmd>CccPick<CR>
'''
lua_source = '''
    local ccc = require("ccc")
    ccc.setup({
      default_color = "#40bfbf",
      bar_char = '█',
      point_char = '|',
      point_color = "#40bfbf",
      highlighter = {
        auto_enable = true,
        lsp = true,
      },
    })
'''

[[plugins]]
repo = 'tyru/capture.vim'
on_cmd = 'Capture'

[[plugins]]
repo = '~/plugin/contextment.vim'
on_map = '<Plug>'
hook_add = '''
    Keymap nxo gc  <Plug>(contextment)
    Keymap n   gcc <Plug>(contextment-line)
'''

[[plugins]]
repo = 'tweekmonster/helpful.vim'
on_cmd = 'HelpfulVersion'

[[plugins]]
repo = 'vim-skk/skkeleton'
depends = 'denops.vim'
on_event = ['InsertEnter', 'CmdlineEnter']
hook_add = '''
    Keymap ic <C-j> <Plug>(skkeleton-toggle)
'''
lua_source = '''
    vim.g["skkeleton#mapped_keys"] = { "<c-l>" }
    vim.fn["skkeleton#register_keymap"]("input", "<c-q>", "katakana")
    vim.fn["skkeleton#register_keymap"]("input", "<c-l>", "zenkaku")
    vim.fn["skkeleton#register_keymap"]("input", "'", "henkanPoint")
    vim.fn["skkeleton#register_kanatable"](
      "azik",
      vim.json.decode(vim.fs.read(vim.fn.stdpath("config") .. "/script/azik.json")),
      true
    )

    vim.fn["skkeleton#config"]({
      kanaTable = "azik",
      eggLikeNewline = true,
      globalDictionaries = {
        "~/.skk/SKK-JISYO.L",
        "~/.skk/SKK-JISYO.edict2",
      },
      markerHenkan = "<>",
      markerHenkanSelect = ">>",
      registerConvertResult = true,
    })

    local function skkeleton_enable()
      vim.keymap.set("l", "<Tab>", "<C-n>", { buffer = true })
      vim.keymap.set("l", "<S-Tab>", "<C-p>", { buffer = true })
      vim.opt_local.cursorline = true
    end

    local function skkeleton_disable()
      vim.keymap.del("l", "<Tab>", { buffer = true })
      vim.keymap.del("l", "<S-Tab>", { buffer = true })
      vim.opt_local.cursorline = false
    end

    local id = vim.api.nvim_create_augroup("my_skkeleton", {})

    vim.api.nvim_create_autocmd("User", {
      group = id,
      pattern = "skkeleton-enable-post",
      callback = skkeleton_enable,
    })

    vim.api.nvim_create_autocmd("User", {
      group = id,
      pattern = "skkeleton-disable-post",
      callback = skkeleton_disable,
    })
'''

[[plugins]]
repo = 'monaqa/dial.nvim'
on_map = '<Plug>'
hook_add = '''
    Keymap nx <C-a> <Plug>(dial-increment)
    xmap g<C-a> g<Plug>(dial-increment)
    Keymap nx <C-x> <Plug>(dial-decrement)
    xmap g<C-x> g<Plug>(dial-decrement)
'''

[[plugins]]
repo = 'mhinz/vim-sayonara'
on_cmd = 'Sayonara'

[[plugins]]
repo = '~/plugin/dressing.nvim'
on_event = "BufEnter"
depends = "fzf-lua"
lua_source = '''
    require("dressing").setup({
      input = {
        enabled = true,
        mappings = {
          n = {
            ["<Esc>"] = { "Close", nowait = true },
            ["q"] = { "Close", nowait = true },
            ["<CR>"] = "Confirm",
          },
          i = {
            ["<C-c>"] = "Close",
            ["<CR>"] = "Confirm",
            ["<Up>"] = "HistoryPrev",
            ["<Down>"] = "HistoryNext",
          },
        },
      },
      select = {
        enabled = true,
        backend = { "fzf_lua", "builtin" },
      },
    })
'''

[[plugins]]
repo = 'lambdalisue/kensaku.vim'
depends = 'denops.vim'
on_cmd = 'KensakuGrep'
hook_post_source = '''
    let romanTable = vimrc#json#read(stdpath('config') . '/script/azik.json')
    let romanTable = values(map(romanTable, { key, val -> [key, val[0], 0] }))
    call kensaku#set_roman_table(romanTable)

    command! -nargs=1 KensakuGrep call KensakuGrep(<q-args>)
    function! KensakuGrep(input) abort
      if !executable('rg')
        return
      endif
      let grepprg = &grepprg
      set grepprg=rg\ -e\ $*\ --vimgrep
      execute 'grep' string(kensaku#query(a:input, {
            \ 'rxop': ['\|', '(', ')', '[', ']', ''],
            \}))
      let &grepprg = grepprg
    endfunction
'''

[[plugins]]
repo = 'mattn/vim-sonictemplate'
on_cmd = 'Template'
hook_source = '''
    let g:sonictemplate_vim_template_dir = stdpath('config') . '/template'
'''

# Plugins for specific filetype

[[plugins]]
repo = 'mattn/vim-maketable'
on_ft = 'markdown'

[[plugins]]
repo = 'tani/glance-vim'
depends = 'denops.vim'
on_cmd = 'Glance'
hook_add = '''
    let g:glance#server_open = v:false
    let g:glance#markdown_plugins = ['https://esm.sh/markdown-it-emoji']

    command! GlanceOpen call s:glance_open()
    function! s:glance_open() abort
      Glance
      call system('vivaldi.exe http://localhost:8765')
    endfunction
'''

[[plugins]]
repo = 'uga-rosa/todo.nvim'
on_ft = 'markdown'
