[[plugins]]
repo = 'williamboman/mason-lspconfig.nvim'
depends = [
    'mason.nvim',
    'nvim-lspconfig',
    'fidget.nvim',
    'cmp-nvim-lsp',
    'actions-preview.nvim'
]
on_event = ['BufReadPre']
lua_post_source = '''
    local api = vim.api
    local lspconfig = require("lspconfig")

    require("rc.lsp")

    local servers = {
      "lua_ls",
      "denols",
      "vimls",
      "gopls",
      "pyright",
      "bashls",
      "tsserver",
    }

    require("mason-lspconfig").setup({
      ensure_installed = servers,
      automatic_installation = true,
    })

    ---@return boolean
    local function is_active_null_ls()
      for _, client in ipairs(vim.lsp.get_active_clients({ bufnr = 0 })) do
        if client.name == "null-ls" then
          return true
        end
      end
      return false
    end

    local function on_attach(_, bufnr)
      local buf_map = function(lhs, rhs)
        vim.keymap.set("n", lhs, rhs, { buffer = bufnr })
      end

      buf_map("K", vim.lsp.buf.hover)
      buf_map("[d", vim.diagnostic.goto_prev)
      buf_map("]d", vim.diagnostic.goto_next)
      buf_map("<leader>n", vim.lsp.buf.rename)
      buf_map("<leader>a", require("actions-preview").code_actions)

      api.nvim_create_user_command("Format", function()
        if vim.bo.filetype == "lua" and not is_active_null_ls() then
          vim.cmd("KeepCursor %!stylua -f ~/.config/stylua.toml -")
        else
          vim.lsp.buf.format()
        end
      end, {})
      buf_map("<leader>F", "<Cmd>Format<CR>")
    end

    local capabilities = vim.lsp.protocol.make_client_capabilities()
    capabilities = require("cmp_nvim_lsp").default_capabilities(capabilities)

    local opts = setmetatable({}, {
      __index = function(self, _)
        return self["*"]
      end,
      __newindex = function(self, key, value)
        value.on_attach = on_attach
        value.capabilities = capabilities
        rawset(self, key, value)
      end,
    })

    opts["*"] = {}

    ---@param rocks string[]
    ---@return string[]
    local function get_rock_path(rocks)
      local root = "/usr/local/share/lua/5.1/"
      local paths = {}
      for _, rock in ipairs(rocks) do
        local path = root .. rock
        if vim.bool_fn.isdirectory(path) then
          table.insert(paths, path)
        else
          vim.notify("Invalid rock name: " .. rock)
        end
      end
      return paths
    end

    ---@param plugins string[]
    ---@return string[]
    local function get_plugin_path(plugins)
      local paths = {}
      for _, plugin in ipairs(plugins) do
        local path = vim.fn["dein#get"](plugin).path
        if path and vim.bool_fn.isdirectory(path .. "/lua") then
          table.insert(paths, path)
        else
          vim.notify("Invalid plugin name: " .. plugin)
        end
      end
      return paths
    end

    ---@param plugins string[]
    ---@param rocks string[]
    ---@return string[]
    local function library(plugins, rocks)
      return vim.list_extend(get_plugin_path(plugins), get_rock_path(rocks))
    end

    opts.lua_ls = {
      settings = {
        Lua = {
          format = {
            enable = false,
          },
          diagnostics = {
            globals = { "vim", "describe", "it", "before_each", "after_each", "setup", "teardown" },
          },
          semantic = {
            enable = false,
          },
          runtime = {
            version = "LuaJIT",
            path = { "lua/?.lua", "lua/?/init.lua", "?.lua", "?/init.lua" },
          },
          workspace = {
            library = library({ "plenary.nvim", "nvim-cmp" }, { "vusted" }),
            checkThirdParty = false,
          },
        },
      },
    }

    opts.bashls = {
      filetypes = { "sh", "bash", "zsh" },
    }

    opts.denols = {
      settings = {
        deno = {
          enable = true,
          suggest = {
            imports = {
              hosts = {
                ["https://deno.land"] = true,
                ["https://crux.land"] = true,
                ["https://x.nest.land"] = true,
              },
            },
          },
        },
      },
    }

    local root_pattern = lspconfig.util.root_pattern

    opts.tsserver = {
      root_dir = function(fname)
        if root_pattern("deno.json")(fname) then
          return nil
        end
        return root_pattern("package.json", "tsconfig.json", "jsconfig.json")(fname)
      end,
      single_file_support = false,
    }

    require("mason-lspconfig").setup_handlers({
      function(server_name)
        lspconfig[server_name].setup(opts[server_name])
      end,
    })
'''

[[plugins]]
repo = 'williamboman/mason.nvim'
lua_post_source = '''
    require("mason").setup()
'''

[[plugins]]
repo = 'neovim/nvim-lspconfig'

[[plugins]]
repo = 'j-hui/fidget.nvim'
lua_source = '''
    require("fidget").setup({})
'''

[[plugins]]
repo = 'hrsh7th/nvim-gtd'
on_event = ['BufRead']
lua_add = '''
    vim.keymap.set("n", "gd", function()
      require("gtd").exec({ command = "edit" })
    end)
'''
lua_source = '''
    local gtd = require("gtd")
    local fzf = require("fzf-lua")
    local builtin = require("fzf-lua.previewer.builtin")

    local custom_previewer = builtin.buffer_or_file:extend()

    function custom_previewer:new(o, opts, fzf_win)
      custom_previewer.super.new(self, o, opts, fzf_win)
      setmetatable(self, custom_previewer)
      return self
    end

    function custom_previewer:parse_entry(entry_str)
      local _, filepath, row, col = entry_str:match("^(%d+)%. (.+):(%d+):(%d+):$")
      return {
        path = filepath,
        line = tonumber(row) or 1,
        col = tonumber(col) or 1,
      }
    end

    gtd.setup({
      sources = {
        { name = "lsp" },
        { name = "findup" },
        { name = "walk" },
      },
      on_locations = function(_, locations)
        local paths, path2location = {}, {}
        for i, location in ipairs(locations) do
          local row = location.targetSelectionRange.start.line + 1
          local col = location.targetSelectionRange.start.character + 1
          local path = ("%s. %s:%s:%s:"):format(i, vim.uri_to_fname(location.targetUri), row, col)
          table.insert(paths, path)
          path2location[path] = location
        end

        local function open_with_cmd(cmd)
          return function(selected, _)
            local location = path2location[selected[1]]
            gtd.open({ command = cmd }, location)
          end
        end

        fzf.fzf_exec(paths, {
          previewer = custom_previewer,
          prompt = "Go to definition> ",
          actions = {
            ["default"] = open_with_cmd("edit"),
            ["ctrl-x"] = open_with_cmd("split"),
            ["ctrl-v"] = open_with_cmd("vsplit"),
            ["ctrl-t"] = open_with_cmd("tabedit"),
          },
        })
      end,
    })
'''

[[plugins]]
repo = 'jose-elias-alvarez/null-ls.nvim'
depends = 'plenary.nvim'
on_ft = ['lua', 'python', 'json']
lua_source = '''
    local null = require("null-ls")
    local b = null.builtins

    null.setup({
      diagnostics_format = "#{m} (#{s}: #{c})",
      sources = {
        -- stylua (lua; formatter)
        function()
          local utils = require("null-ls.utils").make_conditional_utils()
          if utils.root_has_file("stylua.toml") or utils.root_has_file(".stylua.toml") then
            return b.formatting.stylua
          else
            return b.formatting.stylua.with({
              extra_args = { "--config-path", vim.fn.expand("~/.config/stylua.toml") },
            })
          end
        end,
        -- fixjson (json; formatter)
        b.formatting.fixjson,
        -- black (python; formatter)
        b.formatting.black,
      },
    })
'''

[[plugins]]
repo = 'aznhe21/actions-preview.nvim'
depends = 'nui.nvim'
