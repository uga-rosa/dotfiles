[[plugins]]
repo = 'Shougo/dein.vim'

[[plugins]]
repo = 'rebelot/heirline.nvim'
on_event = 'BufEnter'
lua_source = '''
    require("rc.heirline")
'''

[[plugins]]
repo = 'vim-skk/skkeleton'
depends = 'denops.vim'
on_event = 'VimEnter'
lua_add = '''
    vim.keymap.set({ "i", "c" }, "<C-j>", "<Plug>(skkeleton-toggle)")
'''
lua_source = '''
    vim.g["skkeleton#mapped_keys"] = { "<c-l>" }
    vim.fn["skkeleton#register_keymap"]("input", "<c-q>", "katakana")
    vim.fn["skkeleton#register_keymap"]("input", "<c-l>", "zenkaku")
    vim.fn["skkeleton#register_keymap"]("input", "'", "henkanPoint")
    local path = vim.fn.stdpath("config") .. "/script/azik_skkeleton.json"
    local buffer = vim.fs.read(path)
    local kanaTable = vim.json.decode(buffer)
    kanaTable[" "] = "henkanFirst"
    kanaTable["/"] = "abbrev"
    vim.fn["skkeleton#register_kanatable"]("azik", kanaTable, true)

    vim.fn["skkeleton#config"]({
      kanaTable = "azik",
      eggLikeNewline = true,
      globalDictionaries = {
        "~/.skk/SKK-JISYO.L",
        "~/.skk/SKK-JISYO.edict2",
      },
      markerHenkan = "<>",
      markerHenkanSelect = ">>",
      registerConvertResult = true,
    })
'''

[[plugins]]
repo = 'delphinus/skkeleton_indicator.nvim'
on_source = 'skkeleton'
lua_source = '''
    require("skkeleton_indicator").setup()
'''

[[plugins]]
repo = 'hrsh7th/vim-vsnip'
on_event = 'InsertEnter'
on_path = '.*\.snippets'
hook_source = '''
    let g:vsnip_snippet_dir = stdpath('config') . '/snippets'
    let g:vsnip_choice_delay = 200
'''

[[plugins]]
repo = 'cohama/lexima.vim'
on_event = 'InsertEnter'
hook_source = '''
    let g:lexima_ctrlh_as_backspace = 1
    let s:lexima_my_rules = [
          \ #{
          \   char: '<CR>',
          \   at: '{\%#}',
          \   input: '<CR>\ ',
          \   filetype: 'vim'
          \ },
          \ #{
          \   char: '<CR>',
          \   at: '\[\%#]',
          \   input: '<CR>\ ',
          \   filetype: 'vim'
          \ }]
    for rule in s:lexima_my_rules
      call lexima#add_rule(rule)
    endfor
'''

[[plugins]]
repo = 'machakann/vim-sandwich'
on_map = ['<Plug>', '<Plug>(textobj-sandwich-']
lua_add = '''
    vim.g.operator_sandwich_no_default_key_mappings = true
    vim.g.textobj_sandwich_no_default_key_mappings = true
    -- Operator
    vim.keymap.set({ "n", "x", "o" }, "sa", "<Plug>(sandwich-add)")
    vim.keymap.set({ "n", "x" }, "sd", "<Plug>(sandwich-delete)")
    vim.keymap.set("n", "sdb", "<Plug>(sandwich-delete-auto)")
    vim.keymap.set({ "n", "x" }, "sr", "<Plug>(sandwich-replace)")
    vim.keymap.set("n", "srb", "<Plug>(sandwich-replace-auto)")
    -- Textobject
    vim.keymap.set({ "x", "o" }, "ib", "<Plug>(textobj-sandwich-auto-i)")
    vim.keymap.set({ "x", "o" }, "ab", "<Plug>(textobj-sandwich-auto-a)")
    vim.keymap.set({ "x", "o" }, "is", "<Plug>(textobj-query-auto-i)")
    vim.keymap.set({ "x", "o" }, "as", "<Plug>(textobj-query-auto-a)")
'''
hook_source = '''
    call operator#sandwich#set('add', 'char', 'skip_space', 1)
'''

[[plugins]]
repo = 'kana/vim-operator-user'

[[plugins]]
repo = 'yuki-yano/vim-operator-replace'
depends = 'vim-operator-user'
on_map = '<Plug>'
lua_add = '''
    vim.keymap.set({ "n", "x", "o" }, "r", "<Plug>(operator-replace)")
'''

[[plugins]]
repo = 'haya14busa/vim-edgemotion'
on_map = "<Plug>"
lua_add = '''
    vim.keymap.set({ "n", "x", "o" }, "<C-j>", "<Plug>(edgemotion-j)")
    vim.keymap.set({ "n", "x", "o" }, "<C-k>", "<Plug>(edgemotion-k)")
'''

[[plugins]]
repo = 'ibhagwan/fzf-lua'
depends = ['nvim-web-devicons']
on_cmd = 'FzfLua'
on_lua = 'fzf-lua'
lua_add = '''
    vim.keymap.set("n", "<Space>r", "<Cmd>FzfLua resume<CR>")
    vim.keymap.set("n", "<Space>f", "<Cmd>FzfLua files<CR>")
    vim.keymap.set("n", "<Space>b", "<Cmd>FzfLua buffers<CR>")
    vim.keymap.set("n", "<Space>o", "<Cmd>FzfLua oldfiles<CR>")
    vim.keymap.set("n", "<Space>lg", "<Cmd>FzfLua live_grep<CR>")
    vim.keymap.set("n", "<Space>/", "<Cmd>FzfLua blines<CR>")
    vim.keymap.set("n", "<Space>gf", "<Cmd>FzfLua git_files<CR>")
    vim.keymap.set("n", "<Space>h", "<Cmd>FzfLua help_tags<CR>")
    vim.keymap.set("n", "q:", "<Cmd>FzfLua command_history<CR>")
    vim.keymap.set("n", "q;", "q:")
    vim.keymap.set("n", "q/", "<Cmd>FzfLua search_history<CR>")

    -- LSP
    vim.keymap.set("n", "<Space>i", "<Cmd>FzfLua diagnostics_document<CR>")
    vim.keymap.set("n", "gr", "<Cmd>FzfLua lsp_references<CR>")
'''
lua_source = '''
    local actions = require("fzf-lua.actions")

    local exclude_extensions = {
      "png",
      "xlsx",
      "xls",
      "docx",
      "doc",
      "pptx",
      "ppt",
      "pdf",
    }

    -- Default
    local fd_opts = "--color=never --type f --hidden --follow --exclude .git"
    for _, ext in ipairs(exclude_extensions) do
      fd_opts = fd_opts .. (" --exclude '*.%s'"):format(ext)
    end

    require("fzf-lua").setup({
      actions = {
        files = {
          ["default"] = actions.file_edit_or_qf,
          ["ctrl-x"] = actions.file_split,
          ["ctrl-v"] = actions.file_vsplit,
          ["ctrl-t"] = actions.file_tabedit,
          ["alt-q"] = actions.file_sel_to_qf,
          ["alt-l"] = actions.file_sel_to_ll,
        },
        buffers = {
          ["default"] = actions.buf_edit,
          ["ctrl-x"] = actions.buf_split,
          ["ctrl-v"] = actions.buf_vsplit,
          ["ctrl-t"] = actions.buf_tabedit,
        },
      },
      files = {
        prompt = "Files> ",
        fd_opts = fd_opts,
      },
      buffers = {
        actions = {
          ["ctrl-x"] = actions.buf_split,
          ["ctrl-d"] = actions.buf_del,
        },
      },
      file_icon_padding = " ",
    })
'''
[plugins.ftplugin]
fzf = '''
    " See ugaterm config
    tnoremap <buffer> <C-t> <C-t>
'''

[[plugins]]
repo = 'nvim-treesitter/nvim-treesitter'
depends = ['nvim-treesitter-textobjects', 'nvim-ts-rainbow']
on_event = 'BufRead'
hook_post_update = 'TSUpdate'
lua_source = '''
    local parser_install_dir = vim.fn.stdpath("data") .. "/treesitter"
    vim.opt.runtimepath:append(parser_install_dir)

    require("nvim-treesitter.configs").setup({
      highlight = {
        enable = true,
        disable = { "vimdoc" },
      },
      -- lua, vim. help (vimdoc) parser is in neovim core.
      ensure_installed = {
        "toml",
        "query",
        "markdown",
        "python",
        "go",
        "javascript",
        "typescript",
      },
      parser_install_dir = parser_install_dir,
      textobjects = {
        select = {
          enable = true,
          lookahead = true,
          keymaps = {
            ["ib"] = "@block.inner",
            ["ab"] = "@block.outer",
            ["if"] = "@function.inner",
            ["af"] = "@function.outer",
            ["il"] = "@loop.inner",
            ["al"] = "@loop.outer",
          },
        },
        swap = {
          enable = true,
          swap_next = {
            ["<M-s>"] = "@parameter.inner",
          },
          swap_previous = {
            ["<M-S-s>"] = "@parameter.inner",
          },
        },
      },
      rainbow = {
        enable = true,
        extended_mode = true,
        max_file_lines = nil,
      },
    })
'''

[[plugins]]
repo = 'nvim-treesitter/nvim-treesitter-textobjects'

[[plugins]]
repo = 'p00f/nvim-ts-rainbow'

[[plugins]]
repo = 'lambdalisue/fern.vim'
on_cmd = 'Fern'
hook_add = '''
    nnoremap <M-f> <Cmd>Fern . -drawer -toggle<CR>
'''
hook_source = '''
    augroup my-fern
      au!
      au FileType fern call s:fern_mapping()
    augroup END

    function! s:fern_mapping()
      nnoremap <buffer> <C-x> <Plug>(fern-action-open:split)
      nnoremap <buffer> <C-v> <Plug>(fern-action-open:vsplit)
    endfunction
'''

[[plugins]]
repo = 'lewis6991/gitsigns.nvim'
on_event = 'BufRead'
lua_source = '''
    local gs = require("gitsigns")
    gs.setup({
      on_attach = function(bufnr)
        local function map(mode, l, r, opts)
          opts = vim.F.if_nil(opts, {})
          opts.buffer = bufnr
          vim.keymap.set(mode, l, r, opts)
        end
        -- Navigates
        map("n", "]g", function()
          if vim.wo.diff then
            return "]g"
          end
          vim.schedule(function()
            gs.next_hunk()
          end)
          return "<Ignore>"
        end, { expr = true })
        map("n", "[g", function()
          if vim.wo.diff then
            return "[g"
          end
          vim.schedule(function()
            gs.prev_hunk()
          end)
          return "<Ignore>"
        end, { expr = true })
        -- Actions
        map({ "n", "v" }, "<Space>gs", ":Gitsigns stage_hunk<CR>")
        map({ "n", "v" }, "<Space>gu", ":Gitsigns undo_stage_hunk<CR>")
        map({ "n", "v" }, "<Space>gr", ":Gitsigns reset_hunk<CR>")
        -- Text object
        map({ "o", "x" }, "ig", ":<C-U>Gitsigns select_hunk<CR>")
      end,
    })
'''

[[plugins]]
repo = 'lambdalisue/kensaku.vim'
depends = 'denops.vim'
on_cmd = 'KensakuGrep'
hook_post_source = '''
    let romanTable = vimrc#json#read(stdpath('config') . '/script/azik.json')
    let romanTable = values(map(romanTable, { key, val -> [key, val[0], 0] }))
    call kensaku#set_roman_table(romanTable)

    command! -nargs=1 KensakuGrep call KensakuGrep(<q-args>)
    function! KensakuGrep(input) abort
      if !executable('rg')
        return
      endif
      let grepprg = &grepprg
      set grepprg=rg\ -e\ $*\ --vimgrep
      execute 'grep' string(kensaku#query(a:input, {
            \ 'rxop': ['\|', '(', ')', '[', ']', ''],
            \}))
      let &grepprg = grepprg
    endfunction
'''

[[plugins]]
repo = 'hrsh7th/vim-searchx'
depends = 'kensaku.vim'
on_func = 'searchx#start'
lua_add = '''
    vim.keymap.set({ "n", "x" }, "/", "<Cmd>call searchx#start({'dir': 1})<CR>")
    vim.keymap.set({ "n", "x" }, "?", "<Cmd>call searchx#start({'dir': 0})<CR>")
    vim.keymap.set({ "n", "x" }, "n", "<Cmd>call searchx#next()<CR>")
    vim.keymap.set({ "n", "x" }, "N", "<Cmd>call searchx#prev()<CR>")
'''
lua_source = '''
    vim.g.searchx = {
      auto_accept = true,
      scrolloff = vim.opt.scrolloff:get(),
      scrolltime = 0,
      nohlsearch = {
        jump = true,
      },
      markers = vim.split("ASDFGHJKL:QWERTYUIOP", ""),
    }
'''
hook_post_source = '''
    cnoremap <M-j> <Cmd>call ToggleSearchxMigemo()<CR>

    let g:searchx_kensaku = 0
    function! ToggleSearchxMigemo() abort
      let g:searchx_kensaku = !g:searchx_kensaku
      if g:searchx_kensaku
        let g:searchx.convert = { input -> kensaku#query(input) }
      else
        let g:searchx.convert = { input -> input }
      endif
      call searchx#redraw()
      redrawstatus
    endfunction
'''

[[plugins]]
repo = 'yuki-yano/fuzzy-motion.vim'
depends = ['denops.vim', 'kensaku.vim']
on_cmd = 'FuzzyMotion'
hook_add = '''
    nnoremap ss <Cmd>FuzzyMotion<CR>
    let g:fuzzy_motion_matchers = ['fzf', 'kensaku']
'''

[[plugins]]
repo = 'tyru/open-browser.vim'
on_map = '<Plug>(openbrowser-smart-search)'
lua_add = '''
    vim.g.openbrowser_browser_commands = {
      {
        name = "wslview",
        args = { "{browser}", "{uri}" },
      },
    }
    vim.keymap.set({ "n", "x" }, "<M-o>", "<Plug>(openbrowser-smart-search)")
'''

[[plugins]]
repo = 'simeji/winresizer'
on_cmd = 'WinResizerStartResize'
hook_add = '''
    nnoremap <C-e> <Cmd>WinResizerStartResize<CR>
'''

[[plugins]]
repo = 'junegunn/vim-easy-align'
on_map = '<Plug>(EasyAlign)'
lua_add = '''
    vim.keymap.set({ "n", "x" }, "ga", "<Plug>(EasyAlign)")
'''

[[plugins]]
repo = 'thinca/vim-quickrun'
depends = 'vim-quickrun-neovim-job'
on_cmd = 'QuickRun'
hook_add = '''
    nnoremap @r <Cmd>QuickRun<CR>
'''
lua_source = '''
    vim.g.quickrun_config = {
      _ = {
        runner = "neovim_job",
        outputter = "error",
        ["outputter/error/success"] = "buffer",
        ["outputter/error/error"] = "quickfix",
        ["outputter/buffer/opener"] = "botright 10sp",
        ["outputter/buffer/close_on_empty"] = true,
      },
      typescript = {
        command = "deno",
        exec = "%C run -A %S",
      },
      lua = {
        command = "nvim",
        tempfile = "%{tempname()}.lua",
        exec = [[%c --clean --headless -c 'source %s' -c 'cquit 0']],
      },
      nimble = {
        command = "nimble",
        exec = "%C run",
      },
      nimble_test = {
        command = "nimble",
        exec = "%C test",
      },
    }
'''
[plugins.ftplugin]
markdown = '''
    nnoremap <buffer> @r <Cmd>lua require("rc.quickrun").run_under_cursor_block()<CR>
'''

[[plugins]]
repo = 'lambdalisue/vim-quickrun-neovim-job'

[[plugins]]
repo = 'hrsh7th/vim-gindent'
hook_add = '''
    let g:indent = {}
    let g:indent.enabled = { -> index(['vim', 'lua'], &ft) != -1 }
'''

[[plugins]]
repo = 'thinca/vim-partedit'
on_cmd = 'Partedit'
hook_add = '''
    let g:partedit#prefix_pattern = '\s*'
    let g:partedit#auto_prefix = 0
'''

[[plugins]]
repo = 'monaqa/nvim-treesitter-clipping'
depends = ['nvim-treesitter', 'vim-partedit']
on_lua = 'nvim-treesitter-clipping'
lua_add = '''
    vim.api.nvim_create_autocmd("FileType", {
      pattern = { "toml", "markdown" },
      callback = function()
        vim.keymap.set("n", "<C-p>", function()
          require("nvim-treesitter-clipping.internal").clip()
          vim.keymap.set("n", "Q", "<Cmd>w<CR><Cmd>ParteditEnd<CR>", { buffer = true })
        end, { buffer = true })
      end,
    })
'''

[[plugins]]
repo = 'uga-rosa/linkformat.vim'
on_cmd = 'LinkFormatPaste'
hook_add = '''
    let g:linkformat_template = join(['[[plugins]]', "repo = '<>'"], "\n")
'''

[[plugins]]
repo = 'uga-rosa/translate.nvim'
on_cmd = 'Translate'
lua_add = '''
    local mappings = {
      f = "-output=floating",
      s = "-output=split",
      i = "-output=insert",
      r = "-output=replace",
      c = "-comment",
    }

    for k, v in pairs(mappings) do
      vim.keymap.set({"n", "x"}, "mj" .. k, ("<Cmd>Translate JA -source=EN %s<CR><Esc>"):format(v))
      vim.keymap.set({"n", "x"}, "me" .. k, ("<Cmd>Translate EN -source=JA %s<CR><Esc>"):format(v))
    end
'''
lua_source = '''
    require("translate").setup({
      default = {
        command = "translate_shell",
      },
      preset = {
        output = {
          split = {
            append = true,
          },
        },
      },
    })
'''

[plugins.ftplugin]
translate = '''
    nnoremap <buffer><nowait> q <Cmd>quit<CR>
'''

[[plugins]]
repo = 'uga-rosa/ccc.nvim'
on_event = 'BufRead'
hook_add = '''
    nnoremap <C-c> <Cmd>CccPick<CR>
'''
lua_source = '''
    local ccc = require("ccc")

    ccc.setup({
      default_color = "#40bfbf",
      highlighter = {
        auto_enable = true,
        lsp = true,
      },
      pickers = {
        ccc.picker.hex,
        ccc.picker.css_rgb,
        ccc.picker.css_hsl,
        ccc.picker.css_hwb,
        ccc.picker.css_lab,
        ccc.picker.css_lch,
        ccc.picker.css_oklab,
        ccc.picker.css_oklch,
        ccc.picker.trailing_space({
          enable = { "markdown", "help" },
        }),
        ccc.picker.ansi_escape()
      },
    })
'''

[[plugins]]
repo = 'tyru/capture.vim'
on_cmd = 'Capture'

[[plugins]]
repo = 'uga-rosa/contextment.vim'
on_map = '<Plug>'
lua_add = '''
    vim.keymap.set({ "n", "x", "o" }, "gc", "<Plug>(contextment)")
    vim.keymap.set("n", "gcc", "<Plug>(contextment-line)")
'''

[[plugins]]
repo = 'tweekmonster/helpful.vim'
on_cmd = 'HelpfulVersion'

[[plugins]]
repo = 'haya14busa/vim-asterisk'
on_map = '<Plug>'
lua_add = '''
    vim.keymap.set({ "n", "x", "o" }, "*", "<Plug>(asterisk-z*)")
    vim.keymap.set({ "n", "x", "o" }, "#", "<Plug>(asterisk-z#)")
    vim.keymap.set({ "n", "x", "o" }, "g*", "<Plug>(asterisk-gz*)")
    vim.keymap.set({ "n", "x", "o" }, "g#", "<Plug>(asterisk-gz#)")
'''
hook_source = '''
    let g:asterisk#keeppos = 1
'''

[[plugins]]
repo = 'delphinus/emcl.nvim'
on_event = "CmdlineEnter"
lua_source = '''
    require("emcl").setup({
      enabled = {
        "ForwardChar",
        "BackwardChar",
        "BeginningOfLine",
        "EndOfLine",
        "AbortCommand",
        "ForwardWord",
        "BackwardWord",
        "DeleteChar",
        "BackwardDeleteChar",
        "KillWord",
        "DeleteBackwardsToWhiteSpace",
        "BackwardKillWord",
        "TransposeChar",
        "TransposeWord",
        "ToggleExternalCommand",
      },
    })
'''

[[plugins]]
repo = 'monaqa/dial.nvim'
on_map = '<Plug>'
lua_add = '''
    vim.keymap.set({ "n", "x" }, "<C-a>", "<Plug>(dial-increment)")
    vim.keymap.set({ "n", "x" }, "<C-x>", "<Plug>(dial-decrement)")
    vim.keymap.set("x", "g<C-a>", "g<Plug>(dial-increment)")
    vim.keymap.set("x", "g<C-x>", "g<Plug>(dial-decrement)")
'''

[[plugins]]
repo = 'stevearc/dressing.nvim'
on_event = "BufEnter"
depends = "fzf-lua"
lua_source = '''
    require("dressing").setup({
      input = {
        enabled = true,
        mappings = {
          n = {
            ["<Esc>"] = { "Close", nowait = true },
            ["q"] = { "Close", nowait = true },
            ["<CR>"] = "Confirm",
          },
          i = {
            ["<C-c>"] = "Close",
            ["<CR>"] = "Confirm",
            ["<Up>"] = "HistoryPrev",
            ["<Down>"] = "HistoryNext",
          },
        },
      },
      select = {
        enabled = true,
        backend = { "fzf_lua", "builtin" },
      },
    })
'''

[[plugins]]
repo = 'mattn/vim-sonictemplate'
on_cmd = 'Template'
hook_source = '''
    let g:sonictemplate_vim_template_dir = stdpath('config') . '/template'
'''

[[plugins]]
repo = 'thinca/vim-qfreplace'
on_cmd = 'Qfreplace'

[[plugins]]
repo = 'kkiyama117/zenn-vim'
on_func = 'zenn#'
hook_add = '''
    let g:zenn#article#edit_new_cmd = "edit"
    command! -nargs=0 ZennUpdate call zenn#update()
    command! -nargs=0 ZennPreview call zenn#preview()
    command! -nargs=0 ZennStopPreview call zenn#stop_preview()
    command! -nargs=0 ZennNewBook call zenn#new_book()
    command! -nargs=0 ZennNewArticle call s:zenn_new_article()

    function! s:zenn_new_article() abort
      let args_dict = #{ emoji: '🐈' }
      call zenn#article#new_article(args_dict)
            \.then(
            \ { arr -> zenn#echo#echo_msg(arr)})
            \.catch(
            \ { arr -> zenn#echo#echo_err(arr)}
            \)
    endfunction
'''
lua_add = '''
    ---@return string? url
    local function zenn_url()
      local url = "https://zenn.dev/uga_rosa/articles/"
      local name = vim.api.nvim_buf_get_name(0)
      local dirname = vim.fn.fnamemodify(name, ":h:t")
      local extname = vim.fn.fnamemodify(name, ":e")
      if dirname == "articles" and extname == "md" then
        return url .. vim.fn.fnamemodify(name, ":t:r")
      else
        vim.notify("Outside of the zenn article", vim.log.levels.WARN)
      end
    end

    vim.api.nvim_create_user_command("ZennOpen", function()
      local url = zenn_url()
      if url then
        vim.fn.system({ "wslview", url })
      end
    end, {})
'''

[[plugins]]
repo = 'folke/zen-mode.nvim'
on_cmd = 'ZenMode'
lua_source = '''
    local function get_offset()
      local wininfo = vim.fn.getwininfo(vim.api.nvim_get_current_win())[1]
      return wininfo.textoff or 0
    end

    require("zen-mode").setup({
      window = {
        width = function()
          local textwidth = vim.opt.textwidth:get()
          if textwidth > 0 then
            return textwidth + get_offset() * 2
          else
            return 120
          end
        end,
      },
    })
'''

[[plugins]]
repo = 'tani/hey.vim'
depends = 'denops.vim'
on_cmd = 'Hey'
hook_source = '''
    nnoremap <M-u> <Plug>HeyUndo
'''

[[plugins]]
repo = 'delphinus/cellwidths.nvim'
on_event = 'BufEnter'
lua_source = '''
    require("cellwidths").setup({
      name = "default",
    })
'''

[[plugins]]
repo = 'notomo/waitevent.nvim'
on_event = 'VimEnter'
lua_source = '''
    vim.env.GIT_EDITOR = require("waitevent").editor({
      open = function (ctx, path)
        vim.cmd.tabedit(path)
        ctx.tcd()
        vim.bo.bufhidden = "wipe"
      end
    })

    vim.env.EDITOR = require("waitevent").editor({
      done_events = {},
      cancel_events = {},
    })
'''

# Plugins for markdown {{{
[[plugins]]
repo = 'mattn/vim-maketable'
on_ft = 'markdown'

[[plugins]]
repo = 'tani/glance-vim'
depends = 'denops.vim'
on_cmd = 'Glance'
hook_add = '''
    let g:glance#server_open = v:false
    let g:glance#markdown_plugins = ['https://esm.sh/markdown-it-emoji']

    command! GlanceOpen call s:glance_open()
    function! s:glance_open() abort
      Glance
      call system('vivaldi.exe http://localhost:8765')
    endfunction
'''

[[plugins]]
repo = 'uga-rosa/todo.nvim'
on_ft = 'markdown'
# }}}

[[plugins]]
repo = 'Vimjas/vim-python-pep8-indent'
on_ft = 'python'
