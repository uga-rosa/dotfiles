[[plugins]]
repo = 'neovim/nvim-lspconfig'
depends = ['fidget.nvim', 'cmp-nvim-lsp']
on_event = ['BufRead', 'BufNewFile']
lua_source = '''
    local api = vim.api
    local lspconfig = require("lspconfig")

    local servers = {
      "sumneko_lua",
      "denols",
      "vimls",
      "gopls",
      "pyright",
      "bashls",
      "nimls",
      "cssls",
    }

    local function on_attach(_, bufnr)
      local buf_map = function(lhs, rhs)
        vim.keymap.set("n", lhs, rhs, { buffer = bufnr })
      end

      buf_map("K", vim.lsp.buf.hover)
      buf_map("[d", vim.diagnostic.goto_prev)
      buf_map("]d", vim.diagnostic.goto_next)
      buf_map("<leader>n", vim.lsp.buf.rename)
      buf_map("<leader>a", vim.lsp.buf.code_action)

      api.nvim_create_user_command("Format", function()
        vim.lsp.buf.format()
      end, {})
      buf_map("<leader>F", "<Cmd>Format<CR>")
    end

    local capabilities = vim.lsp.protocol.make_client_capabilities()
    capabilities = require("cmp_nvim_lsp").default_capabilities(capabilities)

    local opts = setmetatable({}, {
      __index = function(self, _)
        return self["*"]
      end,
      __newindex = function(self, key, value)
        value.on_attach = on_attach
        value.capabilities = capabilities
        rawset(self, key, value)
      end
    })

    opts["*"] = {}

    ---@param plugins string[]
    ---@return string[]
    local function library(plugins)
      local paths = {}
      for _, plugin in ipairs(plugins) do
        local path = vim.fn["dein#get"](plugin).path
        if path and vim.bool_fn.isdirectory(path .. "/lua") then
          table.insert(paths, path)
        else
          vim.notify("Invalid plugin name: " .. plugin)
        end
      end
      table.insert(paths, vim.fn.stdpath("config"))
      return paths
    end

    opts.sumneko_lua = {
      settings = {
        Lua = {
          format = {
            enable = false,
          },
          diagnostics = {
            globals = { "vim", "describe", "it", "before_each", "after_each", "setup", "teardown" },
          },
          semantic = {
            enable = false,
          },
          runtime = {
            version = "LuaJIT",
            path = { "lua/?.lua", "lua/?/init.lua" },
          },
          workspace = {
            library = library({ "plenary.nvim", "nvim-cmp", "sqlite.lua" }),
            checkThirdParty = false,
          },
        },
      },
    }

    opts.bashls = {
      filetypes = { "sh", "bash", "zsh" },
    }

    opts.denols = {
      settings = {
        deno = {
          enable = true,
          suggest = {
            imports = {
              hosts = {
                ["https://deno.land"] = true,
                ["https://crux.land"] = true,
                ["https://x.nest.land"] = true,
              },
            },
          },
        },
      },
    }

    for _, server in ipairs(servers) do
      lspconfig[server].setup(opts[server])
    end

    -- Diagnostics
    vim.api.nvim_set_hl(0, "NormalFloat", { bg = "#1d3b53" })
    vim.api.nvim_set_hl(0, "Title", { bg = "#1d3b53" })
    vim.api.nvim_set_hl(0, "FloatBorder", { fg = "white", bg = "#1d3b53" })

    vim.diagnostic.config({
      float = {
        border = "single",
        title = "Diagnostics",
        header = {},
        format = function(diag)
          if diag.code then
            return ("[%s](%s): %s"):format(diag.source, diag.code, diag.message)
          else
            return ("[%s]: %s"):format(diag.source, diag.message)
          end
        end,
      },
    })

    -- Hover
    vim.lsp.handlers["textDocument/hover"] = vim.lsp.with(vim.lsp.handlers.hover, {
      border = "single",
      title = "Hover",
    })
'''

[[plugins]]
repo = 'j-hui/fidget.nvim'
lua_source = '''
    require("fidget").setup({})
'''

[[plugins]]
repo = 'hrsh7th/nvim-gtd'
on_event = ['BufRead', 'BufNewFile']
lua_add = '''
    vim.keymap.set("n", "gd", function()
      require("gtd").exec({ command = "edit" })
    end)
'''
lua_source = '''
    local gtd = require("gtd")
    local fzf = require("fzf-lua")
    local builtin = require("fzf-lua.previewer.builtin")

    local custom_previewer = builtin.buffer_or_file:extend()

    function custom_previewer:new(o, opts, fzf_win)
      custom_previewer.super.new(self, o, opts, fzf_win)
      setmetatable(self, custom_previewer)
      return self
    end

    function custom_previewer:parse_entry(entry_str)
      local _, filepath, row, col = entry_str:match("^(%d+)%. (.+):(%d+):(%d+):$")
      return {
        path  = filepath,
        line  = tonumber(row) or 1,
        col   = tonumber(col) or 1,
      }
    end

    gtd.setup({
      sources = {
        { name = "lsp" },
        { name = "findup" },
        { name = "walk" },
      },
      on_locations = function(_, locations)
        local paths, path2location = {}, {}
        for i, location in ipairs(locations) do
          local row = location.targetSelectionRange.start.line + 1
          local col = location.targetSelectionRange.start.character + 1
          local path = ("%s. %s:%s:%s:"):format(i, vim.uri_to_fname(location.targetUri), row, col)
          table.insert(paths, path)
          path2location[path] = location
        end

        local function open_with_cmd(cmd)
          return function (selected, _)
            local location = path2location[selected[1]]
            gtd._open({ command = cmd }, location)
          end
        end

        fzf.fzf_exec(paths, {
          previewer = custom_previewer,
          prompt = "Go to definition> ",
          actions = {
            ["default"] = open_with_cmd("edit"),
            ["ctrl-x"] = open_with_cmd("split"),
            ["ctrl-v"] = open_with_cmd("vsplit"),
            ["ctrl-t"] = open_with_cmd("tabedit"),
          }
        })
      end
    })
'''

[[plugins]]
repo = 'jose-elias-alvarez/null-ls.nvim'
depends = 'plenary.nvim'
on_ft = ['lua', 'python', 'json']
lua_source = '''
    local null = require("null-ls")
    local b = null.builtins

    null.setup({
      diagnostics_format = "#{m} (#{s}: #{c})",
      sources = {
        function()
          local utils = require("null-ls.utils").make_conditional_utils()
          if utils.root_has_file("stylua.toml") then
            return b.formatting.stylua
          elseif utils.root_has_file(".stylua.toml") then
            return b.formatting.stylua.with({
              extra_args = { "--config-path", "./.stylua.toml" },
            })
          else
            return b.formatting.stylua.with({
              extra_args = { "--config-path", vim.fn.expand("~/.config/stylua.toml") },
            })
          end
        end,
        b.formatting.fixjson,
        b.formatting.black,
      },
    })
'''
