[[plugins]]
repo = 'Shougo/dein.vim'

[[plugins]]
repo = 'hrsh7th/vim-vsnip'
on_event = 'InsertEnter'
on_ft = 'snippets'
hook_source = '''
    let g:vsnip_snippet_dir = stdpath('config') . '/snippets'
    let g:vsnip_choice_delay = 200
'''

[[plugins]]
repo = 'cohama/lexima.vim'
on_event = 'InsertEnter'
hook_source = '''
    let g:lexima_ctrlh_as_backspace = 1
    let s:lexima_my_rules = [
          \ #{
          \   char: '<CR>',
          \   at: '{\%#}',
          \   input: '<CR>\ ',
          \   input_after: '<CR>\ ',
          \   filetype: 'vim'
          \ },
          \ #{
          \   char: '<CR>',
          \   at: '\[\%#]',
          \   input: '<CR>\ ',
          \   input_after: '<CR>\ ',
          \   filetype: 'vim'
          \ }]
    for rule in s:lexima_my_rules
      call lexima#add_rule(rule)
    endfor
'''

[[plugins]]
repo = 'machakann/vim-sandwich'
on_map = ['<Plug>(sandwich-', '<Plug>(textobj-sandwich-']
hook_add = '''
    let g:operator_sandwich_no_default_key_mappings = 1
    let g:textobj_sandwich_no_default_key_mappings = 1
    " operator
    Keymap nxo sa <Plug>(sandwich-add)
    Keymap nx  sd <Plug>(sandwich-delete)
    Keymap o   sd <Plug>(sandwich-delete-auto)
    Keymap nx  sr <Plug>(sandwich-replace)
    Keymap o   sr <Plug>(sandwich-replace-auto)
    " textobject
    Keymap xo  ib <Plug>(textobj-sandwich-auto-i)
    Keymap xo  ab <Plug>(textobj-sandwich-auto-a)
    Keymap xo  is <Plug>(textobj-query-auto-i)
    Keymap xo  as <Plug>(textobj-query-auto-a)
'''
hook_source = '''
    call operator#sandwich#set('add', 'char', 'skip_space', 1)
'''

[[plugins]]
repo = 'kana/vim-operator-user'

[[plugins]]
repo = 'yuki-yano/vim-operator-replace'
depends = 'vim-operator-user'
on_map = '<Plug>(operator-replace)'
hook_add = '''
    Keymap nxo r <Plug>(operator-replace)
'''

[[plugins]]
repo = 'haya14busa/vim-edgemotion'
on_map = "<Plug>(edgemotion-"
hook_add = '''
    Keymap nxo <C-j> <Plug>(edgemotion-j)
    Keymap nxo <C-k> <Plug>(edgemotion-k)
'''

[[plugins]]
repo = 'ibhagwan/fzf-lua'
depends = ['nvim-web-devicons', 'mr.vim']
on_cmd = 'FzfLua'
on_lua = 'fzf-lua'
hook_add = '''
    nnoremap <leader>r  <Cmd>FzfLua resume<CR>
    nnoremap <leader>f  <Cmd>FzfLua files<CR>
    nnoremap <leader>b  <Cmd>FzfLua buffers<CR>
    nnoremap <leader>o  <Cmd>FzfLua oldfiles<CR>
    nnoremap <leader>lg <Cmd>FzfLua live_grep<CR>
    nnoremap <leader>/  <Cmd>FzfLua blines<CR>
    nnoremap <leader>gf <Cmd>FzfLua git_files<CR>
    nnoremap <leader>h  <Cmd>FzfLua help_tags<CR>
    nnoremap q:         <Cmd>FzfLua command_history<CR>
    nnoremap q;         q:
    nnoremap q/         <Cmd>FzfLua search_history<CR>

    nnoremap <leader>i  <Cmd>FzfLua diagnostics_document<CR>
    nnoremap gr         <Cmd>FzfLua lsp_references<CR>
'''
lua_add = '''
    vim.keymap.set("n", "<leader>m", function()
      require("fzf-lua").fzf_exec(vim.fn["mr#mru#list"](), {
        previewer = "builtin",
        prompt = "MRU> ",
        fzf_opts = {
          ["--no-sort"] = "",
        },
      })
    end, {})
'''
lua_source = '''
    local actions = require("fzf-lua.actions")
    require("fzf-lua").setup({
      actions = {
        files = {
          ["default"] = actions.file_edit_or_qf,
          ["ctrl-x"]  = actions.file_split,
          ["ctrl-v"]  = actions.file_vsplit,
          ["ctrl-t"]  = actions.file_tabedit,
          ["alt-q"]   = actions.file_sel_to_qf,
          ["alt-l"]   = actions.file_sel_to_ll,
        },
        buffers = {
          ["default"] = actions.buf_edit,
          ["ctrl-x"]  = actions.buf_split,
          ["ctrl-v"]  = actions.buf_vsplit,
          ["ctrl-t"]  = actions.buf_tabedit,
        },
      },
    })
'''

[[plugins]]
repo = 'lambdalisue/mr.vim'
rev = 'main'
hook_source = '''
    let g:mr_mru_disabled = 1
    let g:mr_mrr_disabled = 1
'''

[[plugins]]
repo = 'nvim-treesitter/nvim-treesitter'
depends = ['nvim-treesitter-textobjects', 'nvim-ts-rainbow']
on_event = 'BufRead'
hook_post_update = 'TSUpdate'
lua_source = '''
    local parser_install_dir = vim.fn.stdpath("data") .. "/treesitter"
    vim.opt.runtimepath:append(parser_install_dir)

    require("nvim-treesitter.configs").setup({
      ensure_installed = "all",
      parser_install_dir = parser_install_dir,
      highlight = {
        enable = true,
        disable = {
          "help",
          "typescript",
        },
      },
      textobjects = {
        select = {
          enable = true,
          lookahead = true,
          keymaps = {
            ["ib"] = "@block.inner",
            ["ab"] = "@block.outer",
            ["if"] = "@function.inner",
            ["af"] = "@function.outer",
            ["il"] = "@loop.inner",
            ["al"] = "@loop.outer",
          },
        },
        swap = {
          enable = true,
          swap_next = {
            ["<M-s>"] = "@parameter.inner",
          },
          swap_previous = {
            ["<M-S-s>"] = "@parameter.inner",
          },
        },
      },
      rainbow = {
        enable = true,
        extended_mode = true,
        max_file_lines = nil,
      },
    })
'''

[[plugins]]
repo = 'nvim-treesitter/nvim-treesitter-textobjects'

[[plugins]]
repo = 'p00f/nvim-ts-rainbow'

[[plugins]]
repo = 'nvim-treesitter/playground'
on_cmd = 'TSPlaygroundToggle'

[[plugins]]
repo = 'lambdalisue/fern.vim'
on_cmd = 'Fern'
hook_add = '''
    nnoremap <M-f> <Cmd>Fern . -drawer -toggle<CR>
'''
hook_source = '''
    augroup my-fern
      au!
      au FileType fern call s:fern_mapping()
    augroup END

    function! s:fern_mapping()
      nnoremap <buffer> <C-x> <Plug>(fern-action-open:split)
      nnoremap <buffer> <C-v> <Plug>(fern-action-open:vsplit)
    endfunction
'''

[[plugins]]
repo = 'lewis6991/gitsigns.nvim'
on_event = 'BufRead'
lua_source = '''
    local gs = require("gitsigns")
    gs.setup({
      on_attach = function(bufnr)
        local function map(mode, l, r, opts)
          opts = vim.F.if_nil(opts, {})
          opts.buffer = bufnr
          vim.keymap.set(mode, l, r, opts)
        end
        -- Navigates
        map("n", "]g", function()
          if vim.wo.diff then
            return "]g"
          end
          vim.schedule(function()
            gs.next_hunk()
          end)
          return "<Ignore>"
        end, { expr = true })
        map("n", "[g", function()
          if vim.wo.diff then
            return "[g"
          end
          vim.schedule(function()
            gs.prev_hunk()
          end)
          return "<Ignore>"
        end, { expr = true })
        -- Actions
        map({ "n", "v" }, "<leader>gs", ":Gitsigns stage_hunk<CR>")
        map({ "n", "v" }, "<leader>gu", ":Gitsigns undo_stage_hunk<CR>")
        map({ "n", "v" }, "<leader>gr", ":Gitsigns reset_hunk<CR>")
        -- Text object
        map({ "o", "x" }, "ig", ":<C-U>Gitsigns select_hunk<CR>")
      end,
    })
'''

[[plugins]]
repo = 'hrsh7th/vim-searchx'
on_func = 'searchx#start'
hook_add = '''
    Keymap nx / <Cmd>call searchx#start({'dir': 1})<CR>
    Keymap nx ? <Cmd>call searchx#start({'dir': 0})<CR>

    Keymap nx n     <Cmd>call searchx#next()<CR>
    Keymap c  <C-j> <Cmd>call searchx#next()<CR>
    Keymap nx N     <Cmd>call searchx#prev()<CR>
    Keymap c  <C-k> <Cmd>call searchx#prev()<CR>
    Keymap c  <C-l> <Cmd>call searchx#clear()<CR>
'''
lua_source = '''
    vim.g.searchx = {
      auto_accept = true,
      scrolloff = vim.opt.scrolloff:get(),
      scrolltime = 0,
      nohlsearch = {
        jump = true,
      },
      markers = vim.split("ASDFGHJKL:QWERTYUIOP", ""),
    }
'''

[[plugins]]
repo = 'yuki-yano/fuzzy-motion.vim'
depends = 'denops.vim'
on_cmd = 'FuzzyMotion'
hook_add = '''
    nnoremap ss <Cmd>FuzzyMotion<CR>
'''

[[plugins]]
repo = 'tyru/open-browser.vim'
on_map = '<Plug>(openbrowser-smart-search)'
hook_add = '''
    let g:openbrowser_browser_commands = [
    \   {
    \     'name': 'vivaldi.exe',
    \     'args': ['{browser}', '{uri}']
    \   }
    \]
    Keymap nx <M-o> <Plug>(openbrowser-smart-search)
'''

[[plugins]]
repo = 'simeji/winresizer'
on_cmd = 'WinResizerStartResize'
hook_add = '''
    nnoremap <C-e> <Cmd>WinResizerStartResize<CR>
'''

[[plugins]]
repo = 'junegunn/vim-easy-align'
on_map = '<Plug>(EasyAlign)'
hook_add = '''
    Keymap nx ga <Plug>(EasyAlign)
'''

[[plugins]]
repo = 'thinca/vim-quickrun'
depends = 'vim-quickrun-neovim-job'
on_cmd = 'QuickRun'
hook_add = '''
    nnoremap @r <Cmd>QuickRun<CR>
'''
lua_source = '''
    vim.g.quickrun_config = {
      _ = {
        runner = "neovim_job",
        outputter = "error",
        ["outputter/error/success"] = "buffer",
        ["outputter/error/error"] = "quickfix",
        ["outputter/buffer/opener"] = "botright 10sp",
        ["outputter/buffer/close_on_empty"] = true,
      },
      lua = {
        command = ":luafile",
        exec = "%C %S",
        runner = "vimscript",
      },
      lua_vusted = {
        command = "vusted",
        exec = "%C %s",
      },
      nimble = {
        command = "nimble",
        exec = "%C run",
      },
      nimble_test = {
        command = "nimble",
        exec = "%C test",
      },
    }
'''

[[plugins]]
repo = 'lambdalisue/vim-quickrun-neovim-job'

[[plugins]]
repo = 'hrsh7th/vim-gindent'
hook_add = '''
    let g:indent = {}
    let g:indent.enabled = { -> index(['vim', 'lua'], &ft) != -1 }
'''

[[plugins]]
repo = 'monaqa/vim-partedit'
rev = 'feat-prefix_pattern'
on_cmd = 'Partedit'
on_func = 'partedit#start'
hook_add = '''
    let g:partedit#prefix_pattern = '\s*'
    let g:partedit#auto_prefix = 0
'''

[plugins.ftplugin]
toml_markdown = '''
    nnoremap <buffer> <C-p> <Cmd>call <SID>operator_partedit()<CR>
    function! s:operator_partedit() abort
      let context = context_filetype#get()
      if context.range == [[0, 0], [0, 0]]
        echohl WarningMsg
        echomsg 'Context is not found'
        echohl NONE
        return
      endif
      call partedit#start(context.range[0][0], context.range[1][0],
            \ {'filetype': context.filetype})
      nnoremap <buffer><nowait> Q <Cmd>ParteditEnd<CR>
    endfunction
'''

[[plugins]]
repo = '~/plugin/linkformat.vim'
on_cmd = 'LinkFormatPaste'
hook_add = '''
    let g:linkformat_template = join(['[[plugins]]', "repo = '<>'"], "\n")
'''

[[plugins]]
repo = '4513ECHO/denops-gitter.vim'
depends = 'denops.vim'
on_path = 'gitter://'

[[plugins]]
repo = '~/plugin/translate.nvim'
on_cmd = 'Translate'
lua_add = '''
    local mappings = {
      f = "-output=floating",
      s = "-output=split",
      i = "-output=insert",
      r = "-output=replace",
      c = "-comment",
    }

    for k, v in pairs(mappings) do
      vim.keymap.set({"n", "x"}, "mj" .. k, ("<Cmd>Translate JA -source=EN %s<CR><Esc>"):format(v))
      vim.keymap.set({"n", "x"}, "me" .. k, ("<Cmd>Translate EN -source=JA %s<CR><Esc>"):format(v))
    end
'''
lua_source = '''
    require("translate").setup({
      default = {
        command = "translate_shell",
      },
      preset = {
        output = {
          split = {
            append = true,
          },
        },
      },
    })
'''

[plugins.ftplugin]
translate = '''
    nnoremap <buffer><nowait> q <Cmd>quit<CR>
'''

[[plugins]]
repo = '~/plugin/ccc.nvim'
on_event = 'BufRead'
hook_add = '''
    nnoremap <C-c> <Cmd>CccPick<CR>
'''
lua_source = '''
    require("ccc").setup({
      default_color = "#40bfbf",
      point_color = "#40bfbf",
      highlighter = {
        auto_enable = true,
        lsp = true,
      },
    })
'''

[[plugins]]
repo = 'vim-skk/skkeleton'
depends = 'denops.vim'
on_event = 'InsertEnter'
hook_add = '''
    Keymap ic <C-j> <Plug>(skkeleton-toggle)
'''
hook_source = '''
    call add(g:skkeleton#mapped_keys, '<c-l>')
    lua require("rc.plugins.skkeleton")
    call skkeleton#config(#{
          \ kanaTable: 'azik',
          \ eggLikeNewline: v:true,
          \ globalDictionaries: [
          \   '~/.skk/SKK-JISYO.L',
          \   '~/.skk/SKK-JISYO.edict2',
          \ ],
          \ registerConvertResult: v:true,
          \ })

    au User skkeleton-enable-post call s:skkeleton_enable()
    function! s:skkeleton_enable() abort
      lua CmpSourceSelect("skkeleton")
    endfunction
    au User skkeleton-disable-post lua CmpSourceSelect("default")
'''

[[plugins]]
repo = 'tyru/capture.vim'
on_cmd = 'Capture'

[[plugins]]
repo = '~/plugin/contextment.vim'
on_map = '<Plug>(contextment'
hook_add = '''
    Keymap nxo gc  <Plug>(contextment)
    Keymap n   gcc <Plug>(contextment-line)
'''

# Plugins for specific filetype

[[plugins]]
repo = 'mattn/vim-maketable'
on_ft = 'markdown'

[[plugins]]
repo = 'tani/glance-vim'
depends = 'denops.vim'
on_cmd = 'Glance'
hook_add = '''
    let g:glance#server_open = v:false
    let g:glance#markdown_plugins = ['https://esm.sh/markdown-it-emoji']

    command! GlanceOpen call s:glance_open()
    function! s:glance_open() abort
      Glance
      call system('vivaldi.exe http://localhost:8765')
    endfunction
'''

[[plugins]]
repo = 'uga-rosa/todo.nvim'
on_ft = 'markdown'
